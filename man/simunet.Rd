% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simunet.R
\name{simunet}
\alias{simunet}
\title{Perform social network simulations}
\usage{
simunet(
  Adj = NULL,
  samp.effort = NULL,
  mode = c("directed", "undirected", "max", "min", "upper", "lower", "plus", "vector"),
  n.scans = NULL,
  exp.design = NULL,
  ...,
  edge.Prob = NULL
)
}
\arguments{
\item{Adj}{integer matrix, the reference adjacency matrix to base edge probabilities on. Users
can either:
\itemize{
\item import their own adjacency matrix
\item or rely on the \code{\link[=import_from_asnr]{import_from_asnr()}} function to interact with networks
from the \href{https://github.com/bansallab/asnr}{Animal Social Network Repository}
}}

\item{samp.effort}{integer scalar, the sampling effort, or number of scans, that led to obtaining
of \code{Adj}}

\item{mode}{character scalar, specifies what igraph network \code{mode} should be used to convert the
supplied matrix. Ignored if \code{sampling.param} is provided. Possible values are:
\itemize{
\item \code{"directed"} (the default): for non-symmetrical adjacency matrix where \code{Adj[i,j]} doesn't
have the same meaning as \code{Adj[j,i]}
\item \code{"undirected"}: same as \code{"max"}
\item \code{"upper"}: undirected matrix focusing only on the upper triangle of \code{Adj} (relying on
\code{upper.tri}). Either \code{"upper"} or \code{"lower"} could be favor if only one of \code{Adj[i,j]} and
\code{Adj[j,i]} should be randomized
\item \code{"lower"}: undirected matrix focusing only on the lower triangle of \code{Adj} (relying on
\code{lower.tri})
\item \code{"max"}: from a \code{"directed"} randomization process (both \code{Adj[i,j]} and \code{Adj[j,i]} will be
drawn at each scan), \code{max(Adj[i,j],Adj[j,i])} will be kept for both
\item \code{"min"}: from a \code{"directed"} randomization process (both \code{Adj[i,j]} and \code{Adj[j,i]} will be
drawn at each scan), \code{min(Adj[i,j],Adj[j,i])} will be kept for both
\item \code{"plus."}:  from a \code{"directed"} randomization process (both \code{Adj[i,j]} and \code{Adj[j,i]} will be
drawn at each scan), \code{Adj[i,j] + Adj[j,i]} will be kept for both
\item \code{"vector"}: experimental. To consider adjacency matrices as flat vectors to be randomized.
Relevance unexplored yet.
\item See details in the relevant \code{\link[igraph:graph_from_adjacency_matrix]{igraph}} package
documentation.
}}

\item{n.scans}{integer scalar, number of scans to generate in the simulation}

\item{exp.design}{\code{expDesign} object (cf. \code{\link[=design_exp]{design_exp()}} function, or
\code{?design_exp}), that consists in a sequence of experimental manipulations (functions) to
perform on the (theoretical) scanList to be simulated to obtain a empirical scanList.}

\item{...}{additional arguments to be passed to the function. Specifically, this is used at the
moment to pass more than one \code{expDesign} object to run multiple experiments on a given
theoretical \code{scanList}. This cause the returned object to be a list of empirical \code{scanList},
i.e. a \code{sLlist} object.}

\item{edge.Prob}{optional. An \code{edgeProb} object (cf.
\code{\link[=generate_edgeProb]{generate_edgeProb()}}) that consists in the edge presence probability
matrix at each scan. The probability matrix is drawn from a beta distribution determined via
Bayesian inference, from \code{Adj} and \code{samp.effort}.

\code{edgeProb} object are actually lists that
contain the following components:
\itemize{
\item \code{P}: the edge presence probability matrix
\item \code{Adj}: the inputted adjacency matrix
\item \code{samp.effort}: the inputted sampling effort
\item \code{mode}: the inputted igraph \code{mode}
\item \code{Adj.subfun}: a matrix function, determined from the igraph \code{mode} (cf. ), that return a
logical matrix with \code{TRUE} values only for matrix cells relevant to the igraph \code{mode.} e.g.
only the upper triangle for \code{mode = "upper"}
}}
}
\value{
a \code{scanList} object, primarily a 3 dimensional array representing the (binary) adjacency
matrices (coded within the first two dimensions of the 3D-array) obtained at each simulated
scan (coded as the 3rd dimension of the 3D-array), and a list of attributes.

\code{scanList} objects have this common structure:
\itemize{
\item the 3D-array where the first 2 dimensions are the adjacency matrices (with the node names
from \code{Adj}) and the 3rd dimension is the simulated scan number
\item an attribute named \code{attrs}: a list of objects - see \code{attrs} as a flat list of attributes -
that are recorded throughout the simulation and subsequent experimental manipulations.
We provide an equivalent to r base's \code{attr()} function - \code{\link[=attrs]{attrs()}} - to retrieve
scanList objects' named attributes contained in their \code{attrs}
}
}
\description{
Perform social network simulations
}
\examples{
set.seed(42)
n <- 5L
samp.effort <- 241L

# Adjacency matrix import
## random directed adjacency matrix
Adj <- sample(1:samp.effort,n * n) |>
  matrix(nrow = 5,dimnames = list(letters[1:n],letters[1:n]))
diag(Adj) <- 0L
Adj

## manual lower adjacency matrix
Adj <- c(0, 0, 0, 0,0,
         1, 0, 0, 0,0,
         2, 3, 0, 0,0,
         4, 5, 6, 0,0,
         7, 8, 9,10,0) |>
  matrix(nrow = 5,byrow = TRUE,dimnames = list(as.character(1:n),as.character(1:n)))
Adj

## upper adjacency matrix imported from ASNR (https://github.com/bansallab/asnr)
\dontrun{
  Adj <- import_from_asnr(class = "Mammalia",
                          species = "kangaroo_proximity_weighted",
                          output = "adjacency",type = "upper")
  Adj
}
# this is retrieving and importing this matrix:
node_names <- c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17) |> as.character()
Adj <-
  c(0, 21, 10, 45, 54, 7, 16, 1,  3,  4,  7,  3,  2,  3,  3,  0,  0,
    0,  0,  9, 19, 20, 3,  9, 1, 10,  4, 11,  2,  2,  2,  6,  0,  0,
    0,  0,  0,  8, 10, 3,  5, 1,  9,  4, 10,  0,  0,  0,  3,  2,  0,
    0,  0,  0,  0, 45, 7, 17, 1,  1,  3,  6,  3,  2,  3,  4,  0,  0,
    0,  0,  0,  0,  0, 6, 17, 1,  3,  4,  6,  1,  2,  3,  3,  1,  0,
    0,  0,  0,  0,  0, 0,  4, 1,  2,  2,  3,  3,  3,  1,  4,  0,  0,
    0,  0,  0,  0,  0, 0,  0, 1,  0,  0,  5,  3,  1,  3,  3,  0,  0,
    0,  0,  0,  0,  0, 0,  0, 0,  1,  1,  1,  1,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0, 0,  0, 0,  0,  6,  9,  1,  0,  0,  2,  0,  1,
    0,  0,  0,  0,  0, 0,  0, 0,  0,  0,  8,  1,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0, 0,  0, 0,  0,  0,  0,  1,  2,  0,  5,  0,  0,
    0,  0,  0,  0,  0, 0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0, 0,  0, 0,  0,  0,  0,  0,  0,  1,  3,  0,  0,
    0,  0,  0,  0,  0, 0,  0, 0,  0,  0,  0,  0,  0,  0,  1,  0,  0,
    0,  0,  0,  0,  0, 0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0, 0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0, 0,  0, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0) |>
  matrix(nrow = 17,byrow = TRUE,dimnames = list(node_names,node_names))
Adj

# social network simulations
## theoretical scans
sL <- simunet(Adj = Adj,samp.effort = samp.effort,mode = "upper",n.scans = 120L)
sL
sL |> sum_scans()

## group-scan sampling
### Designing the experiment: setting a constant probability of not observing edges
group.scan <- design_sampling(method = "group",sampling = 0.8)

### simulation can be directly run through the simunet() function
simunet(Adj = Adj,samp.effort = samp.effort,mode = "upper",n.scans = 120L,
        exp.design = group.scan)
### or the experiment can be applied to a theoretical scanList object
group.sL <- perform_exp(sL,group.scan)
group.sL |> count_nonNA()
group.sL |> sum_scans()

## add more scans, perform even focal sampling, then remove the overall most peripheral node
foc.peri_removed <- design_exp(function(x) add_scans(x,200),
                               design_sampling(method = "focal",sampling = "even"),
                               remove_mostPeripheral
)
### or the experiment can be applied to a theoretical scanList object
foc.peri_removed.sL <- perform_exp(sL,foc.peri_removed)
foc.peri_removed.sL |> count_nonNA()
foc.peri_removed.sL |> sum_scans()
}
