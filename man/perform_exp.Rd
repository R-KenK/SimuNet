% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expDesign_tools.R
\name{perform_exp}
\alias{perform_exp}
\title{Perform an experimental design on theoretical \code{scanList}}
\usage{
perform_exp(scan.list, exp.design = NULL, ...)
}
\arguments{
\item{scan.list}{a \code{scanList} object. See objects returned by \code{\link[=simunet]{simunet()}}}

\item{exp.design}{an \code{expDesign} object. See objects returned by \code{\link[=design_exp]{design_exp()}}.
If \code{NULL}, the inputted scan.list is returned as is.}

\item{...}{additional \code{expDesign} object.

If not \code{NULL}, the different expDesign will be applied to \code{scan.list} in "parallel": the
returned value will be a list of empirical \code{scanList}, i.e. a \code{sLlist} object}
}
\value{
an empirical \code{scanList} object representing the simulated theoretical scan on which the
experimental manipulations have been applied. Such objects contain:
\itemize{
\item the 3 dimensional array representing adjacency matrices (first 2 dimensions) throughout the
different scans (3rd dimension)
\item the same \code{attrs} attribute than the inputted \code{scan.list} (a list of attributes), in which
\code{scanList.type = "empirical"}
\item a class \code{empirical}, which inherits from \code{scanList}
\item and other attributes might have been added to \code{attrs} or modifications depending on
\code{exp.design} (e.g. \code{\link[=sum_scans]{sum_scans()}} returns an object of class sum, that inherits
from classes \code{empirical} or \code{theoretical}, and further from \code{scanList})
}

If more than one \code{expDesign} has been inputted via \code{...}, returns a list of empirical
\code{scanList}, i.e. a \code{sLlist} object
}
\description{
Perform an experimental design on theoretical \code{scanList}
}
\examples{
set.seed(42)
n <- 5L
samp.effort <- 100L

# Adjacency matrix import
## random directed adjacency matrix
Adj <- sample(1:samp.effort,n * n) |>
  matrix(nrow = 5,dimnames = list(letters[1:n],letters[1:n]))
Adj[lower.tri(Adj,diag = TRUE)] <- 0L
Adj

# Designing the experiments:
## setting a constant probability of not observing edges
group.scan <- design_exp(customize_sampling(method = "group",sampling = 0.8))

## setting a biased focal sampling favoring central individual (node strength)
focal.scan <- design_exp(
  customize_sampling(
    method = "focal",
    sampling = function(Adj) Adj |>
      igraph::graph.adjacency("upper",weighted = TRUE) |>
      igraph::strength()
  )
)

## Adding more scans, removing the most peripheral individual, before performing an even focal
## sampling
focal.periRemoved <- design_exp(
  function(Adj) add_scans(Adj,42),     # users can use anonymous function to specify arguments
  remove_mostPeripheral,               # ... or pass functions as arguments directly
  customize_sampling(method = "focal",sampling = "even")    # customize_sampling: special case
                                                            # that returns sampling functions
)

# Apply the experimental design
## on previously obtained theoretical scans
sL <- simunet(Adj = Adj,samp.effort = samp.effort,mode = "upper",n.scans = 120L)

perform_exp(sL,group.scan)
perform_exp(sL,focal.periRemoved) |> sum_scans()

## performing a list of experiments
perform_exp(sL,group.scan,focal.scan)
}
\seealso{
\code{\link[=design_exp]{design_exp()}}, \code{\link[=simunet]{simunet()}}, \code{\link[=customize_sampling]{customize_sampling()}}.
}
