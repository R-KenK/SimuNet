% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/obsProb.R
\name{generate_obsProb}
\alias{generate_obsProb}
\title{Generator for `obsProb` objects}
\usage{
generate_obsProb(
  Adj,
  total_scan,
  mode,
  obs.prob_fun = "random",
  Adj.subfun = NULL
)
}
\arguments{
\item{Adj}{square integers matrix of occurrences of dyads.}

\item{total_scan}{integer, sampling effort. Note that 1/total_scan should be relatively small, increasingly small with increasing precision.}

\item{mode}{Character scalar, specifies how igraph should interpret the
supplied matrix. Default here is directed. Possible values are: directed,
undirected, upper, lower, max, min, plus. Added vector too. See details
\link[igraph]{graph_from_adjacency_matrix}.}

\item{obs.prob_fun}{either:
\itemize{
  \item{a user-defined function of (i,j,Adj) that output a probability of
  presence for the dyad}
  \item{a single [0,1] numeric value for all dyad representing their
  probability of being sampled or not (`obs.prob_type` will be `"constant"`)}
  \item{the string `"random"` if each dyad should have its probability drawn
  from a uniform distribution between 0 and 1 (`runif(n*n,0,1)`)}
}}

\item{Adj.subfun}{subsetting function of the adjacency matrix. Driven by
igraph "mode" argument.}
}
\value{
an `obsProb` object (S3 class) containing:
\itemize{
  \item{`P`: a [0,1] numeric matrix of probability of observation (using the
  "group" scan sampling `method`) of each dyad.}
  \item{`Adj`: inputted `Adj`}
  \item{`total_scan`: inputted `total_scan`}
  \item{`obs.prob_type`: character scalar, either:
    \item{`"constant"`: if all dyad have the same probability of being
    sampled or not.}
    \item{`"random"`: if all dyad have a probability drawn from a uniform
    distribution between 0 and 1 (`runif(n*n,0,1)`).}
    \item{`"user-defined function"`: if the user inputted a function of
    (i,j,Adj) to calculate each dyad probability.}
  }
  *
}
}
\description{
Generator for `obsProb` objects
}
\examples{
set.seed(42)

n<- 5;nodes<- as.character(1:n);total_scan<- 42;
Adj<- matrix(data = 0,nrow = n,ncol = n,dimnames = list(nodes,nodes))
Adj[non.diagonal(Adj)]<- sample(0:total_scan,n*(n-1),replace = TRUE)
Adj

generate_obsProb(Adj,total_scan,"directed",obs.prob_fun = "random")
generate_obsProb(Adj,total_scan,"directed",obs.prob_fun = 0.3)

# using a user-defined function:
user_function.ij<- function(i,j,Adj) {i+j} # comparable to a dyad-trait-based bias
user_function.Adj<- function(i,j,Adj) {Adj*Adj} # comparable to a network-based bias

generate_obsProb(Adj,total_scan,"directed",obs.prob_fun = "random")
generate_obsProb(Adj,total_scan,"directed",obs.prob_fun = user_function.ij)
generate_obsProb(Adj,total_scan,"directed",obs.prob_fun = user_function.Adj)

}
