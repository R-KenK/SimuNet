<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Changelog • SimuNet</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/css/bootstrap.min.css" integrity="sha256-bZLfwXAP04zRMK2BjiO8iu9pf4FbLqX6zitd+tIvLhE=" crossorigin="anonymous" />

<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Changelog" />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-news">
      <header>
      <div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">SimuNet</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">2.0.2</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">
    <span class="fas fa-home fa-lg"></span>
     
  </a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../news/index.html">Changelog</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/R-KenK/SimuNet/">
    <span class="fab fa-github fa-lg"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
      <h1 data-toc-skip>Changelog <small></small></h1>
      <small>Source: <a href='https://github.com/R-KenK/SimuNet/blob/master/NEWS.md'><code>NEWS.md</code></a></small>
    </div>

    <div id="simunet-202" class="section level1">
<h1 class="page-header" data-toc-text="2.0.2">
<a href="#simunet-202" class="anchor"></a>SimuNet 2.0.2</h1>
<ul>
<li>enclosed asnr related example in \dontrun{} because some example were sometime not passing on unix systems</li>
</ul>
</div>
    <div id="simunet-201" class="section level1">
<h1 class="page-header" data-toc-text="2.0.1">
<a href="#simunet-201" class="anchor"></a>SimuNet 2.0.1</h1>
<ul>
<li>small edit in import_from_asnr()’s doc: now should pass R CMD check across systems (windows and unix)</li>
</ul>
</div>
    <div id="simunet-200" class="section level1">
<h1 class="page-header" data-toc-text="2.0.0">
<a href="#simunet-200" class="anchor"></a>SimuNet 2.0.0</h1>
<ul>
<li>Switch internal simulation framework to one relying on Bayesian inference:
<ul>
<li>
<code>edgeProb</code>: edge presence probability matrices, renamed from <code>presenceProb</code>, are now drawn before each simulations from a posterior Beta distribution:
<ul>
<li>inferred from the observed weighted adjacency matrix and a prior Beta distribution (at the moment with <code>alpha.prior = beta.prior = 0.5</code>, i.e. Jeffrey’s prior). Specifically, from a distribution <code><a href="https://rdrr.io/r/stats/Beta.html">Beta(Adj + alpha.prior,samp.effort - Adj + beta.prior)</a></code>
</li>
<li>
<code>edgeProb</code> is drawn before each simulation: different <code>edgeProb</code>s will be obtained from a given <code>Adj</code> and <code>samp.effort</code>, but all of them come from this common posterior Beta distribution</li>
<li>This process of randomly drawing an <code>edgeProb</code> from a Beta distribution that would be used for all subsequent scans of a given simulation is akin to a Beta-Binomial process. However, “simply” drawing from a Beta-Binomial distribution would only provide a new weighted adjacency matrix, and not multiple binary scans that represent each scan, which is not desirable</li>
<li>Now, the desired behavior of having uncertainty and sampling effort included in the simulation should be attained</li>
</ul>
</li>
<li>Uncertainty inherent from this Bayesian inference paradigm can be assessed via replicating many simulations, for which different <code>edgeProb</code> will be drawn</li>
</ul>
</li>
<li>Switch from list of scans (list of 2D matrices) to 3 dimensional arrays:
<ul>
<li>the first 2 dimensions are the binary adjacency matrices for each scan</li>
<li>the 3rd dimension is the scan index<br>
This provides faster simulation and manipulations, but required an important rewriting of internal functions. Reliance on a new S3 class, <code>scanList</code>, should allow for fairly transparent manipulation, however</li>
</ul>
</li>
<li>New <code>scanList</code> object are the new class of object returned by the new main wrapper, renamed <code><a href="../reference/simunet.html">simunet()</a></code>. They now consist in 2 mains components:
<ul>
<li>the 3D array representing the edges at each scans, the actual object</li>
<li>a single attribute <code>attrs</code>, which is a list, containing all relevant attributes to keep track of</li>
<li>Operations/functions applied to <code>scanList</code> object should default to being applied to the 3D array. This approach (not having scanList object being primary a list) was used for intuitiveness</li>
<li>
<code>scanList</code> attributes list <code>attrs</code> can be accessed via the new function <code><a href="../reference/attrs.html">attrs()</a></code>, analogous to <code>base</code>’s <code><a href="https://rdrr.io/r/base/attr.html">attr()</a></code>
</li>
</ul>
</li>
<li>Empiricism and empirical <code>scanList</code>s have been rethought:
<ul>
<li>They now rely on a new class of objects and two main functions:
<ul>
<li>
<code>expDesign</code> objects which consist in function sequences to apply to a theoretical <code>scanList</code> to obtain an empirical one. These functions can be viewed as experimental manipulations of interest to simulate, e.g. node removal, observation error, etc.</li>
<li>
<code><a href="../reference/design_exp.html">design_exp()</a></code>: used to create <code>expDesign</code> objects. Inputted functions are chained via <code>purrr</code>’s <code>invoke()</code> function.</li>
<li>
<code><a href="../reference/perform_exp.html">perform_exp()</a></code>: used to apply an <code>expDesign</code> objects to <code>scanList</code> objects</li>
<li>
<code><a href="../reference/simunet.html">simunet()</a></code> is now overall a wrapper to generate <code>edgeProb</code>, simulate a theoretical <code>scanList</code>, and can handle <code>expDesign</code> objects to directly obtain empirical <code>scanList</code>s. Otherwise, users can first generate a theoretical scanList and later apply <code>expDesign</code> to them via <code><a href="../reference/perform_exp.html">perform_exp()</a></code>
</li>
</ul>
</li>
<li>In a similar fashion to data manipulation with tidyverse’s functions, or similarly to how image editors can rely on layers, <code>expDesign</code> objects expect experimental manipulations to be chained and combined. Therefore, they should accept <code>scanList</code> objects as their first argument, and return a modified <code>scanList</code> onto which other manipulation could be applied. Special cases like collapsing binary scans into their sum within a weighted adjacency matrix (<code><a href="../reference/sum_scans.html">sum_scans()</a></code>), or their scaled equivalent (<code><a href="../reference/scale_scans.html">scale_scans()</a></code>), can also be used at the end of the function sequence.</li>
<li>Common manipulations are included in the package a experimental design “building blocks”. Such include so far:
<ul>
<li>
<code><a href="../reference/add_scans.html">add_scans()</a></code>: draws additional scans based on the inputted <code>scanList</code>’s edge.Prob. For instance, to compensate expectable sampling effort difference between two experimental designs</li>
<li>
<code><a href="../reference/remove_mostPeripheral.html">remove_mostPeripheral()</a></code>, to remove the overall most peripheral individual from all scans</li>
<li>
<code><a href="../reference/sum_scans.html">sum_scans()</a></code> and <code><a href="../reference/scale_scans.html">scale_scans()</a></code>, to be use to collapse binary scans into weighted adjacency matrices, for instance at the end of a manipulation sequence</li>
</ul>
</li>
<li>Empirical sampling, with group-scan and focal-scan sampling, are now handled as (part of) experimental designs passed as <code>expDesign</code> objects, as such “building blocks”:
<ul>
<li>the function <code><a href="../reference/customize_sampling.html">customize_sampling()</a></code> can be used to define commonly defined group and focal sampling method, and can accept like previously:
<ul>
<li>in the case of group-scan sampling:
<ul>
<li>constant or random probabilities of observing an edge</li>
<li>observation probabilities derived from user-defined functions</li>
</ul>
</li>
<li>in the case of focal-scan sampling:
<ul>
<li>even or random probabilities of observing an edge</li>
<li>focal selection probabilities derived from user-defined functions</li>
</ul>
</li>
</ul>
</li>
<li>
<code><a href="../reference/customize_sampling.html">customize_sampling()</a></code> returns a function that can be used as a design “building block” within <code><a href="../reference/design_exp.html">design_exp()</a></code>
</li>
</ul>
</li>
<li>These “building blocks”, as functions of <code>scanList</code>s returning <code>scanList</code>s, do not need to be used within <code>expDesign</code> object, but can verbosely chained/piped from <code>scanList</code> object (taking advantage of base’s new pipe <code>|&gt;</code> for instance). This is particularly useful for <code><a href="../reference/sum_scans.html">sum_scans()</a></code> and <code><a href="../reference/scale_scans.html">scale_scans()</a></code> for instance</li>
<li>Provided “building blocks” are also written to handle list of <code>scanList</code>s, i.e. list of class <code>sLlist</code>, and return a list of what they would have return. This allow for simple design of several <code>expDesign</code> objects passed simultaneously to be applied to a <code>scanList</code> object through <code><a href="../reference/perform_exp.html">perform_exp()</a></code>, to later be able to compare their outputs.</li>
</ul>
</li>
<li>Otherwise rework done on the whole code from the ground up, documentation improved with links, and generally attempt at optimization here and there</li>
</ul>
</div>
    <div id="simunet-140" class="section level1">
<h1 class="page-header" data-toc-text="1.4.0">
<a href="#simunet-140" class="anchor"></a>SimuNet 1.4.0</h1>
<ul>
<li>WIP: started writing tools to interact with the <code>ANTs</code> package. Barely started.</li>
</ul>
</div>
    <div id="simunet-1309000" class="section level1">
<h1 class="page-header" data-toc-text="1.3.0.9000">
<a href="#simunet-1309000" class="anchor"></a>SimuNet 1.3.0.9000</h1>
<ul>
<li>Added a homemade class of packed matrices: <code>snPackMat</code> (SimuNet Packed Matrix) that stores only a vector of the relevant data, as well as a way to unpack the matrix to a regular one. Especially designed to avoid storing empry matrix triangles and performing useless operations on them. Now <code>simu_scan</code> has an optional use.snPackMat logical argument (<code>FALSE</code> by default). Early benchmarks are promising</li>
<li>Added two user-friendly functions to interact with the <a href="http://www.github.com/bansallab/asnr">Animal Social Network Repository</a>:
<ul>
<li>
<code>import_from_asnr</code> can mostly be used with:
<ul>
<li>the Class and species folder (in the Networks folder of the github repository), and possibly graphml file name, as character strings</li>
<li>the URL of a graphml object within the repository<br>
an option allows the user to easily retrieve a igraph network object, or an adjacency matrix, from the graphml file</li>
</ul>
</li>
<li>
<code>asnr_network_df</code> retrieve the list (into a dataframe) of graphml file in the asnr repository. Internally used by <code>import_from_asnr</code>
</li>
</ul>
</li>
</ul>
</div>
    <div id="simunet-1209000" class="section level1">
<h1 class="page-header" data-toc-text="1.2.0.9000">
<a href="#simunet-1209000" class="anchor"></a>SimuNet 1.2.0.9000</h1>
<ul>
<li>Switched internally to integer matrices instead of numeric matrices: significant improvement of -10% computation time and -30% memory allocation on a <code>n = 21</code> <code>total_scan = 9000</code> empirical network</li>
<li>Added dependency/reliance on the <code>Matrix</code> package, notably for its printing of sparse matrices</li>
</ul>
</div>
    <div id="simunet-110" class="section level1">
<h1 class="page-header" data-toc-text="1.1.0">
<a href="#simunet-110" class="anchor"></a>SimuNet 1.1.0</h1>
<ul>
<li>implemented a plot method for <code>scan</code> and <code>empiScan</code> objects. Internal code probably cleanable, but working for now: <code><a href="https://rdrr.io/r/graphics/plot.default.html">plot()</a></code> can be used either on a <code>scan</code>/<code>empiScan</code> object (which will be passed through <code><a href="https://rdrr.io/r/base/summary.html">summary()</a></code>) or on a <code>summary.scan</code>/<code>summary.empiScan</code> one. Notable <code>plot</code> arguments available: <code>method</code> to choose within <code><a href="https://rdrr.io/r/base/c.html">c("both","theoretical","group","focal")</a></code> for <code>empiScan</code> objects. Special case of the <code>layout</code> argument used to pass igraphs <code>layout</code> or <code>layout_</code> functions internally. This way, a layout is determined before calling <code>plot.igraph</code> (wrapped in <code>plot_emprical</code>) in the case of <code>method = "both"</code>, to ensure that all networks rely on the same layout to ease visual comparison.</li>
</ul>
</div>
    <div id="simunet-101" class="section level1">
<h1 class="page-header" data-toc-text="1.0.1">
<a href="#simunet-101" class="anchor"></a>SimuNet 1.0.1</h1>
<ul>
<li>fixed some ugly print outputs for long <code>focalList</code> objects</li>
</ul>
</div>
    <div id="simunet-100" class="section level1">
<h1 class="page-header" data-toc-text="1.0.0">
<a href="#simunet-100" class="anchor"></a>SimuNet 1.0.0</h1>
<ul>
<li>v1.0.0 Release of a fully functional and documented version of this network simulation framework, including a shift toward OOP internally</li>
</ul>
</div>
    <div id="simunet-0609000" class="section level1">
<h1 class="page-header" data-toc-text="0.6.0.9000">
<a href="#simunet-0609000" class="anchor"></a>SimuNet 0.6.0.9000</h1>
<ul>
<li>Added track of <code>X.scaled</code> (X being <code>"theoretical"</code>, <code>"group"</code>, or <code>"focal"</code>) for <code>summary.scan</code> and <code>summary.empiScan</code> objects</li>
</ul>
</div>
    <div id="simunet-0509000" class="section level1">
<h1 class="page-header" data-toc-text="0.5.0.9000">
<a href="#simunet-0509000" class="anchor"></a>SimuNet 0.5.0.9000</h1>
<ul>
<li>Renamed more explicitely the <code>X.scan</code> components of scan and empiScan object, to make way for <code>X.sum</code> and <code>X.sampled</code> new matrices (cf. below).</li>
<li>The <code>summary</code>method used on <code>scan</code> and <code>empiScan</code> objects can now be used to create objects of new <code>summary.scan</code> and <code>summary.empiScan</code> objects, storing <code>X.sum</code> and <code>X.sampled</code> (X being <code>"theoretical"</code>, <code>"group"</code>, or <code>"focal"</code>), and with dedicated print methods</li>
<li>
<code>Adj</code> and <code>total_scan</code> arguments are now optional when <code>sampling.param</code> is passed when using <code>simu_scan</code>
</li>
<li>Added several required function for this purpose:
<ul>
<li>
<code>sum_scan.list</code> is an equivalent of previous <code>sum_up.scan(s)</code>, but cleaner. It sums up any list of scans counting <code>NA</code>s as zeros.</li>
<li>added <code>resolve_NA</code>, which is called before <code>sum_scan.list</code> in the case of empirical scans. Moved all <code>NA</code>s related functions to <code>empirical_NA_tools.R</code>
</li>
<li>added <code>sum_scan.sampled</code> and <code>count_NA</code> functions to also count sampled (non-<code>NA</code>) edges</li>
</ul>
</li>
</ul>
</div>
    <div id="simunet-0409000" class="section level1">
<h1 class="page-header" data-toc-text="0.4.0.9000">
<a href="#simunet-0409000" class="anchor"></a>SimuNet 0.4.0.9000</h1>
<ul>
<li>Included <code>scans.to.do</code> variable (a scan index <em>or</em> a vector of <code>1:total_scan</code>) in wrappers and nested functions to generate <code>scan</code> and <code>empiScan</code> objects. Now <code>scans.to.do</code> is stored in several internal and output objects</li>
<li>Vectorized wrappers and nested functions to produce lists of scans (<code>raw.scan</code>, <code>theoretical.scan</code>, <code>group.scan</code> or <code>focal.scan</code> empirical scans)</li>
<li>Updated several print methods to display vectorized or list components of <code>scan</code>, <code>empiScan</code> and <code>samplingParam</code> objects, truncate them when required to not overload output</li>
</ul>
</div>
    <div id="simunet-0309000" class="section level1">
<h1 class="page-header" data-toc-text="0.3.0.9000">
<a href="#simunet-0309000" class="anchor"></a>SimuNet 0.3.0.9000</h1>
<ul>
<li>Added a wrapper to <code>generate_samplingParam</code>. User should interact with <code>simu_samplingParam</code> to create <code>samplingParam</code> objects for their simulations.</li>
<li>Vectorized the <code>focal</code> and <code>scans.to.do</code> (which now replace <code>scan.number</code> for more transparency) components of <code>focal</code> objects. Next version should also vectorize some components of <code>samplingParam</code>, <code>obsProb</code>, <code>scan</code>, and <code>empiScan</code> objects</li>
<li>Finalized a working version of <code>simu_scan</code> for single theoretical and empirical scan. Next version should allow the user to directly use <code>simu_scan</code> to generate a list of either types of scans (thus superseding former <code>iterate_scans</code>).</li>
<li>Homogenize some function and variable names.</li>
</ul>
</div>
    <div id="simunet-0209000" class="section level1">
<h1 class="page-header" data-toc-text="0.2.0.9000">
<a href="#simunet-0209000" class="anchor"></a>SimuNet 0.2.0.9000</h1>
<ul>
<li>First shift toward integration of OOP elements into the simulation framework:
<ul>
<li>Revamp from the ground up of the <code>do.scan</code> part of the non-OOP previous version</li>
<li>Attempt at homogenizing SimuNet’s internal syntax:
<ul>
<li>the wrappers - to perform the whole network simulations (former <code>Boot_scan()</code>), iterate single scans into weighted adjacency matrix (former <code>iterate_scans()</code>), and draw a single random binary scan (former <code>do.scan()</code>) - will now follow the syntax <code>simu_*()</code> (starting with the <code>simu_scan()</code> wrapper to supersede <code>do.scan()</code>)</li>
<li>new simulation internal objects (cf. below) will have generator following the syntax <code>generate_className()</code>, and as needed <code>print.className()</code> and other relevant S3 class methods.</li>
<li>presently, their related code use variable names distinct from their <code>className</code> syntax, rather favoring a <code>variable = class.name</code> syntax internally</li>
<li>function names including internal ones are (hopefully) more explicit, and are now action verbs to follow coding “grammar” recommendations</li>
</ul>
</li>
</ul>
</li>
<li>For the OOP-transition purpose, creation of several simulation objects (S3 class):
<ul>
<li>
<code>presenceProb</code> objects, generator and related S3 methods: calculate and store infos on the presence probability <code>P</code> of a tie at each scan for each dyad, from inputted adjacency matrix (<code>Adj</code>), sampling effort (<code>total_scan</code>), and igraph network <code>mode</code>
</li>
<li>
<code>samplingParam</code> objects, generator and related S3 methods: store all usefull parameters, some in the form of new object classes (S3), related to the empirical aspect of the network simulation. Presently, stores what’s needed for a single binary focal scan, i.e. infos on a single focal (out of a list of focals). Specifically, <code>samplingParam</code> objects store:
<ul>
<li>
<code>method</code>: a character scalar between <code>"group"</code>,<code>"focal"</code> and <code>"both"</code>, indicating the chosen scan sampling method.</li>
<li>
<code>mode</code>: a character scalar representing the igraph network <code>mode</code>.</li>
<li>
<code>obsProb</code> objects (cf. below)</li>
<li>
<code>focal</code> objects (cf. below)</li>
</ul>
</li>
<li>
<code>obsProb</code> objects, generator and related S3 methods: calculate and store a probability of observation <code>P</code> of an edge at each scan sampling for each dyad, from inputted user-defined function <code>obs.prob_fun</code> of <code>(i,j,Adj)</code> (that can also be used to pass a single [0,1] numeric to use as a constant, or the string <code>"random"</code> to have all dyad probability drawn from <code><a href="https://rdrr.io/r/stats/Uniform.html">runif(n*n,0,1)</a></code>)</li>
<li>
<code>focalList</code> objects, generator and related S3 methods: draw and store a list <code>focals</code> of <code>total_scan</code> focals (used internally as their indices, but also keep track of their names), from inputted user-defined function <code>focal.prob_fun</code> of <code>(n,Adj)</code> (that should return a vector of <code>n</code> probability for each node to be drawn at each scan, but that can also be used to pass as the strings <code>"random"</code> or <code>"even"</code> to have them drawn from <code><a href="https://rdrr.io/r/base/sample.html">sample()</a></code> or to maximize the evenness of drawn focals in the focal list)</li>
<li>
<code>focal</code> objects, generator and related S3 methods (including <code>plot.scan</code> S3 method to plot the network relying on <code>plot.igraph</code>): determine and store which <code>focal</code> to sample, from inputted <code>focalList</code> object (cf. above) and <code>scan.number</code> (out of the sampling effort <code>total_scan</code>)</li>
<li>
<code>scan</code> objects, generator and related S3 methods: draw and store, from inputted <code>presenceProb</code> object:
<ul>
<li>a <code>raw</code> scan: directed binary matrix drawn from the probability of presence of edges contained in a <code>presenceProb</code> object</li>
<li>a <code>theoretical</code> scan: the <code>raw</code> scan to which the selected mode has been applied</li>
<li>a <code>scan.type</code> scan string: for <code>scan</code> object not sampled from yet (i.e. not empirical scans of the <code>empiScan</code> class (cf.below)), <code>scan$scan.type = "theoretical"</code>, but later in the process can become <code>"empirical"</code>
</li>
<li>the original adjacency matrix <code>Adj</code>, sampling effort <code>total_scan</code>, selected igraph network <code>mode</code>, the probability matrix <code>presence.prob</code> (from <code>presenceProb$P</code>), and other parameters mostly for internal use</li>
</ul>
</li>
<li>
<code>empiScan</code> objects, generator and related S3 methods: draw and store, from inputted <code>scan</code> and <code>samplingParam</code> objects:
<ul>
<li>inherits from the <code>scan</code> S3 class</li>
<li>but have their <code>scan.type = "empirical"</code>
</li>
<li>a <code>method</code> string from <code>samplingParam$method</code>
</li>
<li>and both/either a <code>group</code> and/or <code>focal</code> scan: matrix/matrices containing* <code>0</code>,<code>1</code>, or <code>NA</code>, which represents an edge that hasn’t been sampled. Internally sample from <code>scan$theoretical</code>, to which the igraph network <code>mode</code> was already applied, and is set to keep <code>NA</code>s where they were drawn (relevant for <code>"group"</code> scan sampling), even if this result in a undirected adjacency matrix where <code>NA</code>s are non-symetrical. A function to minimize solvable <code>NA</code>s will be soon introduced: for <code>mode = "max"</code>, this is e.g. when <code>scan$raw[i,j] = 1</code> and <code>scan$raw[j,i] = NA</code> or inversly, for which both values can be set to <code>1</code>; for <code>mode = "min"</code>, this is e.g. when <code>scan$raw[i,j] = 0</code> and <code>scan$raw[j,i] = NA</code> or inversly, for which both values can be set to <code>0</code>. *: with <code>mode = "plus"</code>, possible values also include <code>2</code>
</li>
</ul>
</li>
</ul>
</li>
<li>Revamping from the ground up as the new object were formalized and introduced in the algorithm, the internal code also got cleaned and fixed in some places as code was recycled from its previous non-OOP state:
<ul>
<li>Some functions were updated to split some of their overall work into additional more explicit and more “single-step/purpose” functions (e.g. <code>generate_obsProb</code> now relies on <code>determine_obs.prob_type</code> and <code>calculate_obs.prob</code> instead of containing all the code in itself)</li>
<li>
<code>empiScan$focal</code> now show not only the line of the <code>focal</code> sampled, but also its column</li>
<li>rethinking of the way the igraph network <code>mode</code> is applied: <code>apply_mode</code> now keep track of an always <code>"directed"</code> <code>raw</code> scan, makes it symmetrical into a <code>theoretical</code> scan if an undirected <code>mode</code> is selected (<code>"undirected"</code>, <code>"max"</code>, <code>"min"</code>, or <code>"plus"</code>), from which a <code>focal</code> and <code>group</code> scans are sampled through <code>sample_from_scan</code> (that internally relies on <code>group_sample</code> and <code>focal_sample</code>). Through this changes, internal algorithm changed significantly, especially in how <code>NA</code>s are handled in <code>group</code> scans. Also, <code>zero_NA</code> has been generalized into <code>replace_NA</code>, with subsequent changes in <code>compare_with_transposed</code>, but these are not used anymore within <code>apply_mode</code> and are kept for now just in case.</li>
<li>removed normally-superseded <code>*.R</code> files (<code>focal.list.R</code>, <code>obs.prob_._tools</code>), renamed <code>do.scan.R</code> into <code>do.scan.old.R</code>
</li>
</ul>
</li>
</ul>
</div>
    <div id="simunet-010" class="section level1">
<h1 class="page-header" data-toc-text="0.1.0">
<a href="#simunet-010" class="anchor"></a>SimuNet 0.1.0</h1>
<ul>
<li>Imported simulation-oriented functions from ConfiNet</li>
<li>Structure package till it checks ok on its own</li>
<li>Commented and removed mention of <code>decide_use.rare.opti()</code> for now till this routine is cleaned. Updated examples in <code>Boot_scans()</code> and bootstrap tools to not call for this function through setting <code>use.rare.opti = FALSE</code>
</li>
<li>Added a <code>NEWS.md</code> file to track changes to the package.</li>
</ul>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>

</div>


      <footer>
      <div class="copyright">
  <p>Developed by Kenneth Keuk.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


